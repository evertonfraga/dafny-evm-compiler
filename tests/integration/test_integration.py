import unittest
from pathlib import Path
from src.dafny_compiler import DafnyEVMCompiler

def get_test_compiler():
    return DafnyEVMCompiler(verify=False)

class TestIntegration(unittest.TestCase):
    def setUp(self):
        self.compiler = get_test_compiler()
        self.fixtures_dir = Path('tests/fixtures')
    
    def test_compile_all_fixtures(self):
        """Test that all fixture contracts compile successfully"""
        for dfy_file in self.fixtures_dir.glob('*.dfy'):
            with self.subTest(contract=dfy_file.name):
                result = self.compiler.compile_file(str(dfy_file))
                self.assertTrue(result['success'], 
                    f"Failed to compile {dfy_file.name}: {result.get('error')}")
                self.assertGreater(len(result['bytecode']), 0)
    
    def test_simple_token_structure(self):
        """Test SimpleToken has expected structure"""
        result = self.compiler.compile_file('tests/fixtures/SimpleToken.dfy')
        self.assertTrue(result['success'])
        self.assertEqual(result['contract_name'], 'SimpleToken')
        self.assertIn('object "SimpleToken"', result['yul_code'])
    
    def test_counter_methods(self):
        """Test Counter contract has all expected methods"""
        result = self.compiler.compile_file('tests/fixtures/Counter.dfy')
        self.assertTrue(result['success'])
        
        yul = result['yul_code']
        self.assertIn('function constructor()', yul)
        self.assertIn('function increment()', yul)
        self.assertIn('function decrement()', yul)
        self.assertIn('function reset()', yul)
        self.assertIn('function getCount()', yul)
    
    def test_erc20_token_features(self):
        """Test ERC20Token has all features"""
        result = self.compiler.compile_file('tests/fixtures/ERC20Token.dfy')
        self.assertTrue(result['success'])
        
        yul = result['yul_code']
        self.assertIn('function mint()', yul)
        self.assertIn('function burn()', yul)
        self.assertIn('function pause()', yul)
        self.assertIn('function unpause()', yul)
    
    def test_bytecode_size_limits(self):
        """Test that generated bytecode is within reasonable limits"""
        for dfy_file in self.fixtures_dir.glob('*.dfy'):
            result = self.compiler.compile_file(str(dfy_file))
            bytecode_size = len(result['bytecode']) // 2
            self.assertLess(bytecode_size, 24576,  # 24KB limit
                f"{dfy_file.name} exceeds size limit: {bytecode_size} bytes")
    
    def test_deterministic_compilation(self):
        """Test that compilation is deterministic"""
        source_file = 'tests/fixtures/SimpleToken.dfy'
        
        result1 = self.compiler.compile_file(source_file)
        result2 = self.compiler.compile_file(source_file)
        
        self.assertEqual(result1['bytecode'], result2['bytecode'])
        self.assertEqual(result1['yul_code'], result2['yul_code'])
    
    def test_precondition_enforcement(self):
        """Test that preconditions are enforced in generated code"""
        source = """
        class Test {
          var value: uint256
          
          method setValue(v: uint256)
            requires v > 0
            requires v < 1000
          {
            value := v;
          }
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])
        
        # Check that requires are translated to checks
        yul = result['yul_code']
        self.assertIn('if iszero', yul)
        self.assertIn('revert', yul)
    
    def test_postcondition_verification(self):
        """Test that postconditions are present"""
        source = """
        class Test {
          var count: uint256
          
          method increment()
            ensures count == old(count) + 1
          {
            count := count + 1;
          }
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])
        # Postconditions are verified by Dafny, not enforced in EVM
    
    def test_storage_layout(self):
        """Test that storage slots are assigned correctly"""
        source = """
        class Test {
          var slot0: uint256
          var slot1: uint256
          var slot2: uint256
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])
        
        yul = result['yul_code']
        self.assertIn('sstore(0', yul)
        self.assertIn('sstore(1', yul)
        self.assertIn('sstore(2', yul)

class TestSecurityPatterns(unittest.TestCase):
    def setUp(self):
        self.compiler = DafnyEVMCompiler(verify=False)
    
    def test_overflow_protection(self):
        """Test overflow protection via preconditions"""
        source = """
        class SafeMath {
          var value: uint256
          
          method add(a: uint256)
            requires a <= 1000
            requires value + a <= 1000
          {
            value := value + a;
          }
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])
    
    def test_access_control_pattern(self):
        """Test access control implementation"""
        source = """
        class Owned {
          var owner: address
          var initialized: bool
          
          method initialize()
            requires !initialized
            ensures initialized
          {
            initialized := true;
          }
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])
    
    def test_pausable_pattern(self):
        """Test pausable contract pattern"""
        source = """
        class Pausable {
          var paused: bool
          
          method pause()
            requires !paused
            ensures paused
          {
            paused := true;
          }
          
          method operation()
            requires !paused
          {
            // Operation
          }
        }
        """
        result = self.compiler.compile(source)
        self.assertTrue(result['success'])

if __name__ == '__main__':
    unittest.main()
