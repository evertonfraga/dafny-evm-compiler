const { expect } = require("chai");
const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

describe("SimpleToken (Dafny Compiled)", function () {
  let token;
  let owner, addr1;

  beforeEach(async function () {
    [owner, addr1] = await ethers.getSigners();

    // Load artifact generated by Dafny compiler
    const artifactPath = path.resolve(__dirname, "../contracts-out/SimpleToken.json");
    const artifact = JSON.parse(fs.readFileSync(artifactPath, "utf8"));

    // Deploy contract using artifact
    const factory = new ethers.ContractFactory(
      artifact.abi,
      artifact.bytecode,
      owner
    );
    token = await factory.deploy();
    await token.deployed();
  });

  describe("Deployment", function () {
    it("Should deploy successfully", async function () {
      expect(token.address).to.match(/^0x[a-fA-F0-9]{40}$/);
    });

    it("Should have bytecode deployed", async function () {
      const code = await ethers.provider.getCode(token.address);
      expect(code).to.not.equal("0x");
      expect(code.length).to.be.greaterThan(2);
    });
  });

  describe("getBalance", function () {
    it("Should return balance (initially 0)", async function () {
      const balance = await token.getBalance();
      expect(balance.toNumber()).to.equal(0);
    });
  });

  describe("mint", function () {
    it("Should mint tokens", async function () {
      const tx = await token.mint(1000);
      await tx.wait();
      expect(tx).to.exist;
    });

    it("Should revert on zero amount", async function () {
      try {
        await token.mint(0);
        expect.fail("Should have reverted");
      } catch (error) {
        expect(error.message).to.include("revert");
      }
    });
  });

  describe("transfer", function () {
    it("Should transfer tokens when balance is sufficient", async function () {
      // First mint to have balance
      await token.mint(1000);
      
      const transferAmount = 100;
      const success = await token.transfer(transferAmount);
      
      expect(success).to.equal(true);
    });

    it("Should revert on zero amount", async function () {
      await token.mint(1000);
      try {
        await token.transfer(0);
        expect.fail("Should have reverted");
      } catch (error) {
        expect(error.message).to.include("revert");
      }
    });

    it("Should revert when balance is insufficient", async function () {
      // Don't mint, so balance is 0
      try {
        await token.transfer(100);
        expect.fail("Should have reverted");
      } catch (error) {
        expect(error.message).to.include("revert");
      }
    });
  });

  describe("Gas Usage", function () {
    it("Should report gas usage for mint", async function () {
      const tx = await token.mint(1000);
      const receipt = await tx.wait();
      console.log(`      Gas used for mint: ${receipt.gasUsed.toString()}`);
      expect(receipt.gasUsed.toNumber()).to.be.lessThan(100000);
    });

    it("Should report gas usage for transfer", async function () {
      await token.mint(1000);
      const gasEstimate = await token.estimateGas.transfer(100);
      console.log(`      Gas used for transfer: ${gasEstimate.toString()}`);
      expect(gasEstimate.toNumber()).to.be.lessThan(100000);
    });
  });
});
